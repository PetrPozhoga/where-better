{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nimport React, { useState, useEffect } from 'react';\nimport styles from './SlideShow.module.scss';\n\nconst SlideShow = ({\n  children = [],\n  showElements,\n  animationTime = 300,\n  classNameContainer,\n  slideHeight,\n  idRoot,\n  paddingLeft,\n  paddingRight,\n  marginRight,\n  windowInnerWidth\n}) => {\n  const {\n    0: rootElement,\n    1: setRootElement\n  } = useState({});\n  const {\n    0: wrapElement,\n    1: setWrapElement\n  } = useState({});\n  const {\n    0: containerElement,\n    1: setContainerElement\n  } = useState({});\n  const {\n    0: copyChildren,\n    1: setCopyChildren\n  } = useState([]);\n  const {\n    0: slideOption,\n    1: setSlideOption\n  } = useState({\n    totalSlide: children.length,\n    currentIndex: 0,\n    currentElementIndex: 0\n  });\n  const {\n    0: slideIsOver,\n    1: setSlideIsOver\n  } = useState(false);\n  useEffect(() => {\n    setRootElement(document.getElementById(styles.root + idRoot));\n  }, [rootElement]);\n  useEffect(() => {\n    setWrapElement(document.querySelector('.' + classNameContainer));\n  }, [wrapElement]);\n  useEffect(() => {\n    let container = document.querySelector('.' + styles.container + classNameContainer);\n    setContainerElement(container);\n    container.style.transition = 'left ease ' + animationTime + 'ms';\n    console.log('left linear ' + animationTime + 'ms');\n    let slideItem = document.querySelectorAll('.' + styles.container + classNameContainer + '>div');\n    slideItem.forEach((item, index) => {\n      console.log((wrapElement.offsetWidth - (showElements - 1) * marginRight) / showElements);\n      item.style.width = (wrapElement.offsetWidth - (showElements - 1) * (marginRight || 0)) / showElements + 'px';\n      item.style.marginRight = (marginRight || 0) + 'px';\n    });\n  }, [containerElement, windowInnerWidth]);\n  useEffect(() => {\n    document.querySelector('.' + styles.container + classNameContainer).style.marginLeft = slideOption.currentIndex * (wrapElement.offsetWidth / showElements) + 'px';\n  }, [windowInnerWidth]);\n  useEffect(() => {\n    console.log(children);\n    setCopyChildren(children.slice());\n  }, [children]);\n\n  const changeSlide = slide => {\n    if (slideIsOver) return false;else {\n      setSlideIsOver(true);\n      let newChildrenArr = [];\n      let currentIndex = slideOption.currentIndex + slide;\n      let currentElementIndex = slideOption.currentElementIndex + slide;\n      currentElementIndex = currentElementIndex < 0 ? copyChildren.length - 1 : currentElementIndex > copyChildren.length - 1 ? 0 : currentElementIndex;\n\n      if (slide === 1) {\n        let firstChild = copyChildren[0];\n        newChildrenArr = [].concat(_toConsumableArray(copyChildren.slice(1, copyChildren.length)), [firstChild]);\n      } else {\n        let lastChild = copyChildren[copyChildren.length - 1];\n        newChildrenArr = [lastChild].concat(_toConsumableArray(copyChildren.slice(0, copyChildren.length - 1)));\n      }\n\n      setSlideOption(_objectSpread({}, slideOption, {\n        currentIndex,\n        currentElementIndex\n      }));\n      setTimeout(() => {\n        setCopyChildren(newChildrenArr);\n        document.querySelector('.' + styles.container + classNameContainer).style.marginLeft = currentIndex * (wrapElement.offsetWidth / showElements) + 'px';\n      }, slide === 1 ? animationTime : 0);\n      setTimeout(() => {\n        setSlideIsOver(false);\n      }, animationTime);\n    }\n  };\n\n  const setCurrentSlide = index => {\n    if (slideOption.currentElementIndex === index) return;else {\n      let container = document.querySelector('.' + styles.container + classNameContainer);\n      container.style.transition = 'none';\n      let currentIndex = index - slideOption.currentElementIndex;\n      let newChildrenArr = [];\n\n      if (currentIndex >= 1) {\n        let firstChild = copyChildren.slice(0, Math.abs(currentIndex));\n        console.log(firstChild);\n        newChildrenArr = [].concat(_toConsumableArray(copyChildren.slice(Math.abs(currentIndex), copyChildren.length)), _toConsumableArray(firstChild));\n      } else {\n        let lastChild = copyChildren.slice(copyChildren.length - Math.abs(currentIndex), copyChildren.length);\n        copyChildren.splice(copyChildren.length - Math.abs(currentIndex), lastChild.length);\n        newChildrenArr = [].concat(_toConsumableArray(lastChild), _toConsumableArray(copyChildren));\n      }\n\n      setSlideOption(_objectSpread({}, slideOption, {\n        currentIndex: slideOption.currentIndex + currentIndex,\n        currentElementIndex: index\n      }));\n      setCopyChildren(newChildrenArr);\n      container.style.marginLeft = (slideOption.currentIndex + currentIndex) * (wrapElement.offsetWidth / showElements) + 'px';\n      setTimeout(() => container.style.transition = 'left ease ' + animationTime + 'ms', animationTime);\n    }\n  };\n\n  return __jsx(\"div\", {\n    className: styles.root,\n    id: styles.root + idRoot\n  }, __jsx(\"div\", {\n    style: {\n      height: slideHeight,\n      position: 'relative'\n    }\n  }, __jsx(\"div\", {\n    style: {\n      width: rootElement.offsetWidth - (paddingLeft || 0) - (paddingRight || 0) + 'px'\n    },\n    className: styles.wrapp + ' ' + classNameContainer\n  }, __jsx(\"div\", {\n    className: styles.container + ' ' + styles.container + classNameContainer,\n    style: {\n      left: -(slideOption.currentIndex * (wrapElement.offsetWidth / showElements)) + 'px',\n      width: wrapElement && (wrapElement.offsetWidth + (marginRight || 0) * (showElements - 1)) / showElements * copyChildren.length + 'px'\n    }\n  }, copyChildren.map(item => item))), __jsx(\"div\", {\n    className: styles.arrowControl\n  }, __jsx(\"svg\", {\n    onClick: changeSlide.bind(null, 1),\n    width: \"50\",\n    height: \"50\",\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, __jsx(\"circle\", {\n    cx: \"25\",\n    cy: \"25\",\n    r: \"25\",\n    fill: \"#4D3E3D\",\n    fillOpacity: \"0.5\"\n  }), __jsx(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M31.0722 36.7022L27.9061 39.8683L12.8904 24.8526L27.9061 9.83691L31.0722 13.003L19.2226 24.8526L31.0722 36.7022Z\",\n    fill: \"white\"\n  })), __jsx(\"svg\", {\n    width: \"50\",\n    height: \"50\",\n    viewBox: \"0 0 50 50\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    onClick: changeSlide.bind(null, 1)\n  }, __jsx(\"circle\", {\n    r: \"25\",\n    transform: \"matrix(-1 0 0 1 25 25)\",\n    fill: \"#4D3E3D\",\n    fillOpacity: \"0.5\"\n  }), __jsx(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M18.9277 36.7022L22.0938 39.8683L37.1096 24.8526L22.0938 9.83691L18.9277 13.003L30.7773 24.8526L18.9277 36.7022Z\",\n    fill: \"white\"\n  })))), __jsx(\"div\", {\n    className: styles.circleControl\n  }, copyChildren.map((item, key) => __jsx(\"div\", {\n    key: key + item,\n    onClick: setCurrentSlide.bind(null, key),\n    className: slideOption.currentElementIndex === key ? styles.activeCircle : ''\n  }))));\n};\n\nexport default SlideShow;","map":null,"metadata":{},"sourceType":"module"}